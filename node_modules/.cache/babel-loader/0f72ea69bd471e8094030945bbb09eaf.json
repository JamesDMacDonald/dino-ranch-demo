{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules } from 'react-native';\n/**\n * simple hook wrapper for async functions for 'on-mount / componentDidMount' that only need to fired once\n * @param asyncGetter async function that 'gets' something\n * @param initialResult -1 | false | 'unknown'\n */\n\nexport function useOnMount(asyncGetter, initialResult) {\n  const [response, setResponse] = useState({\n    loading: true,\n    result: initialResult\n  });\n  useEffect(() => {\n    // async function cuz react complains if useEffect's effect param is an async function\n    const getAsync = async () => {\n      const result = await asyncGetter();\n      setResponse({\n        loading: false,\n        result\n      });\n    };\n\n    getAsync();\n  }, [asyncGetter]);\n  return response;\n}\nexport const deviceInfoEmitter = new NativeEventEmitter(NativeModules.RNDeviceInfo);\n/**\n * simple hook wrapper for handling events\n * @param eventName\n * @param initialValueAsyncGetter\n * @param defaultValue\n */\n\nexport function useOnEvent(eventName, initialValueAsyncGetter, defaultValue) {\n  const {\n    loading,\n    result: initialResult\n  } = useOnMount(initialValueAsyncGetter, defaultValue);\n  const [result, setResult] = useState(defaultValue); // sets the result to what the intial value is on mount\n\n  useEffect(() => {\n    setResult(initialResult);\n  }, [initialResult]); // - set up the event listener to set the result\n  // - set up the clean up function to remove subscription on unmount\n\n  useEffect(() => {\n    const subscription = deviceInfoEmitter.addListener(eventName, setResult);\n    return () => subscription.remove();\n  }, [eventName]); // loading will only be true while getting the inital value. After that, it will always be false, but a new result may occur\n\n  return {\n    loading,\n    result\n  };\n}","map":{"version":3,"sources":["asyncHookWrappers.ts"],"names":["useState","loading","result","initialResult","useEffect","getAsync","asyncGetter","setResponse","deviceInfoEmitter","NativeModules","useOnMount","setResult","subscription"],"mappings":"AAAA,SAAA,QAAA,EAAA,SAAA,QAAA,OAAA;AACA,SAAA,kBAAA,EAAA,aAAA,QAAA,cAAA;AAGA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,UAAA,CAAA,WAAA,EAAA,aAAA,EAA4F;AACjG,QAAM,CAAA,QAAA,EAAA,WAAA,IAA0BA,QAAQ,CAAqB;AAC3DC,IAAAA,OAAO,EADoD,IAAA;AAE3DC,IAAAA,MAAM,EAAEC;AAFmD,GAArB,CAAxC;AAKAC,EAAAA,SAAS,CAAC,MAAM;AACd;AACA,UAAMC,QAAQ,GAAG,YAAY;AAC3B,YAAMH,MAAM,GAAG,MAAMI,WAArB,EAAA;AACAC,MAAAA,WAAW,CAAC;AAAEN,QAAAA,OAAO,EAAT,KAAA;AAAkBC,QAAAA;AAAlB,OAAD,CAAXK;AAFF,KAAA;;AAKAF,IAAAA,QAAQ;AAPD,GAAA,EAQN,CARHD,WAQG,CARM,CAATA;AAUA,SAAA,QAAA;AACD;AAED,OAAO,MAAMI,iBAAiB,GAAG,IAAA,kBAAA,CAAuBC,aAAa,CAA9D,YAA0B,CAA1B;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,UAAA,CAAA,SAAA,EAAA,uBAAA,EAAA,YAAA,EAIe;AACpB,QAAM;AAAA,IAAA,OAAA;AAAWP,IAAAA,MAAM,EAAEC;AAAnB,MAAqCO,UAAU,CAAA,uBAAA,EAArD,YAAqD,CAArD;AACA,QAAM,CAAA,MAAA,EAAA,SAAA,IAAsBV,QAAQ,CAFhB,YAEgB,CAApC,CAFoB,CAIpB;;AACAI,EAAAA,SAAS,CAAC,MAAM;AACdO,IAAAA,SAAS,CAATA,aAAS,CAATA;AADO,GAAA,EAEN,CAPiB,aAOjB,CAFM,CAATP,CALoB,CASpB;AACA;;AACAA,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMQ,YAAY,GAAGJ,iBAAiB,CAAjBA,WAAAA,CAAAA,SAAAA,EAArB,SAAqBA,CAArB;AACA,WAAO,MAAMI,YAAY,CAAzB,MAAaA,EAAb;AAFO,GAAA,EAGN,CAdiB,SAcjB,CAHM,CAATR,CAXoB,CAgBpB;;AACA,SAAO;AAAA,IAAA,OAAA;AAAWF,IAAAA;AAAX,GAAP;AACD","sourcesContent":["import { useState, useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules } from 'react-native';\nimport { AsyncHookResult } from './types';\n\n/**\n * simple hook wrapper for async functions for 'on-mount / componentDidMount' that only need to fired once\n * @param asyncGetter async function that 'gets' something\n * @param initialResult -1 | false | 'unknown'\n */\nexport function useOnMount<T>(asyncGetter: () => Promise<T>, initialResult: T): AsyncHookResult<T> {\n  const [response, setResponse] = useState<AsyncHookResult<T>>({\n    loading: true,\n    result: initialResult,\n  });\n\n  useEffect(() => {\n    // async function cuz react complains if useEffect's effect param is an async function\n    const getAsync = async () => {\n      const result = await asyncGetter();\n      setResponse({ loading: false, result });\n    };\n\n    getAsync();\n  }, [asyncGetter]);\n\n  return response;\n}\n\nexport const deviceInfoEmitter = new NativeEventEmitter(NativeModules.RNDeviceInfo);\n\n/**\n * simple hook wrapper for handling events\n * @param eventName\n * @param initialValueAsyncGetter\n * @param defaultValue\n */\nexport function useOnEvent<T>(\n  eventName: string,\n  initialValueAsyncGetter: () => Promise<T>,\n  defaultValue: T\n): AsyncHookResult<T> {\n  const { loading, result: initialResult } = useOnMount(initialValueAsyncGetter, defaultValue);\n  const [result, setResult] = useState<T>(defaultValue);\n\n  // sets the result to what the intial value is on mount\n  useEffect(() => {\n    setResult(initialResult);\n  }, [initialResult]);\n\n  // - set up the event listener to set the result\n  // - set up the clean up function to remove subscription on unmount\n  useEffect(() => {\n    const subscription = deviceInfoEmitter.addListener(eventName, setResult);\n    return () => subscription.remove();\n  }, [eventName]);\n\n  // loading will only be true while getting the inital value. After that, it will always be false, but a new result may occur\n  return { loading, result };\n}\n"]},"metadata":{},"sourceType":"module"}