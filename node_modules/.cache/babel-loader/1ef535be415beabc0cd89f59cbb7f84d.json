{"ast":null,"code":"\"use strict\";\n/**\r\n * @typedef {Object} NTPPacket\r\n * @property {int} leapIndicator\r\n * @property {int} version\r\n * @property {int} mode\r\n * @property {int} stratum\r\n * @property {int} poll\r\n * @property {int} precision\r\n * @property {Date} rootDelay\r\n * @property {Date} rootDispersion\r\n * @property {String} referenceId\r\n * @property {Date} referenceTimestamp\r\n * @property {Date} originTimestamp\r\n * @property {Date} receiveTimestamp\r\n * @property {Date} transmitTimestamp\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar NtpPacketParser = function () {\n  function NtpPacketParser() {\n    _classCallCheck(this, NtpPacketParser);\n  }\n\n  _createClass(NtpPacketParser, null, [{\n    key: \"_getBits\",\n\n    /**\r\n    * Returns the selected bits in binary notation\r\n    * @param msg\r\n    * @param {int} start\r\n    * @param {int} length\r\n    * @returns {string} Bits in binary notation\r\n    * @private\r\n    */\n    value: function _getBits(msg, start, length) {\n      var bits = \"\";\n      var pad = \"00000000\";\n\n      for (var i = 0; i < msg.length; i++) {\n        var bitsUnpadded = (msg[i] >>> 0).toString(2);\n        bits += pad.substring(0, pad.length - bitsUnpadded.length) + bitsUnpadded;\n      }\n\n      return bits.slice(start, start + length);\n    }\n    /**\r\n    * Converts a NTP identifier from binary notation to ASCII\r\n    * @param {int} stratum\r\n    * @param {String} value Bits in binary notation\r\n    * @returns {string}\r\n    * @private\r\n    */\n\n  }, {\n    key: \"_ntpIdentifier\",\n    value: function _ntpIdentifier(stratum, value) {\n      if (stratum != 1) {\n        return parseInt(value, 2).toString();\n      }\n\n      var chars = [value.slice(0, 8), value.slice(8, 16), value.slice(16, 24), value.slice(24, 32)];\n      chars = chars.map(function (v) {\n        return String.fromCharCode(parseInt(v, 2));\n      });\n      return chars.join(\"\").replace(/\\0+$/, \"\");\n    }\n    /**\r\n    * Converts a NTP timestamp from binary notation to a Date object\r\n    * @param {String} value Bits in binary notation\r\n    * @returns {Date}\r\n    * @private\r\n    */\n\n  }, {\n    key: \"_fromNtpTimestamp\",\n    value: function _fromNtpTimestamp(value) {\n      if (value.length % 2 !== 0) {\n        throw new Error(\"Invalid timestamp format, expected even number of characters\");\n      }\n\n      var seconds = parseInt(value, 2) / Math.pow(2, value.length / 2),\n          date = new Date(\"Jan 01 1900 GMT\");\n      date.setUTCMilliseconds(date.getUTCMilliseconds() + seconds * 1000);\n      return date;\n    }\n    /**\r\n    * Parses an UDP packet buffer and returns a NTPPacket struct\r\n    * @param {Buffer} udpPacket\r\n    * @returns {NTPPacket}\r\n    */\n\n  }, {\n    key: \"parse\",\n    value: function parse(udpPacket) {\n      var data = [];\n      NtpPacketParser.packetStruct.forEach(function (item) {\n        data[item.name] = undefined;\n      });\n      var offset = 0;\n      NtpPacketParser.packetStruct.forEach(function (item) {\n        data[item.name] = NtpPacketParser._getBits(udpPacket, offset, item.bits);\n\n        if (item.converter) {\n          data[item.name] = item.converter(data[item.name], data);\n        } else {\n          data[item.name] = parseInt(data[item.name], 2);\n        }\n\n        offset += item.bits;\n      });\n      return data;\n    }\n  }, {\n    key: \"packetStruct\",\n\n    /**\r\n    * Returns the structure of the UDP packet for parsing\r\n    * @returns {Object}\r\n    */\n    get: function get() {\n      var _this = this;\n\n      return [{\n        name: \"leapIndicator\",\n        bits: 2\n      }, {\n        name: \"version\",\n        bits: 3\n      }, {\n        name: \"mode\",\n        bits: 3\n      }, {\n        name: \"stratum\",\n        bits: 8\n      }, {\n        name: \"poll\",\n        bits: 8\n      }, {\n        name: \"precision\",\n        bits: 8\n      }, {\n        name: \"rootDelay\",\n        bits: 32,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }, {\n        name: \"rootDispersion\",\n        bits: 32,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }, {\n        name: \"referenceId\",\n        bits: 32,\n        converter: function converter(v, s) {\n          return _this._ntpIdentifier(s.stratum, v);\n        }\n      }, {\n        name: \"referenceTimestamp\",\n        bits: 64,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }, {\n        name: \"originTimestamp\",\n        bits: 64,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }, {\n        name: \"receiveTimestamp\",\n        bits: 64,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }, {\n        name: \"transmitTimestamp\",\n        bits: 64,\n        converter: NtpPacketParser._fromNtpTimestamp\n      }];\n    }\n  }]);\n\n  return NtpPacketParser;\n}();\n\nexports.default = NtpPacketParser;","map":{"version":3,"sources":["/home/main/Documents/dino-ranch-landing/node_modules/ntp-packet-parser/dist/index.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","NtpPacketParser","_getBits","msg","start","bits","pad","bitsUnpadded","toString","substring","slice","_ntpIdentifier","stratum","parseInt","chars","map","v","String","fromCharCode","join","replace","_fromNtpTimestamp","Error","seconds","Math","pow","date","Date","setUTCMilliseconds","getUTCMilliseconds","parse","udpPacket","data","packetStruct","forEach","item","name","undefined","offset","converter","get","_this","s","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\r\n * @typedef {Object} NTPPacket\r\n * @property {int} leapIndicator\r\n * @property {int} version\r\n * @property {int} mode\r\n * @property {int} stratum\r\n * @property {int} poll\r\n * @property {int} precision\r\n * @property {Date} rootDelay\r\n * @property {Date} rootDispersion\r\n * @property {String} referenceId\r\n * @property {Date} referenceTimestamp\r\n * @property {Date} originTimestamp\r\n * @property {Date} receiveTimestamp\r\n * @property {Date} transmitTimestamp\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar NtpPacketParser = (function() {\n  function NtpPacketParser() {\n    _classCallCheck(this, NtpPacketParser);\n  }\n\n  _createClass(NtpPacketParser, null, [\n    {\n      key: \"_getBits\",\n\n      /**\r\n     * Returns the selected bits in binary notation\r\n     * @param msg\r\n     * @param {int} start\r\n     * @param {int} length\r\n     * @returns {string} Bits in binary notation\r\n     * @private\r\n     */\n      value: function _getBits(msg, start, length) {\n        var bits = \"\";\n        var pad = \"00000000\";\n\n        for (var i = 0; i < msg.length; i++) {\n          var bitsUnpadded = (msg[i] >>> 0).toString(2);\n          bits +=\n            pad.substring(0, pad.length - bitsUnpadded.length) + bitsUnpadded;\n        }\n\n        return bits.slice(start, start + length);\n      }\n\n      /**\r\n     * Converts a NTP identifier from binary notation to ASCII\r\n     * @param {int} stratum\r\n     * @param {String} value Bits in binary notation\r\n     * @returns {string}\r\n     * @private\r\n     */\n    },\n    {\n      key: \"_ntpIdentifier\",\n      value: function _ntpIdentifier(stratum, value) {\n        if (stratum != 1) {\n          return parseInt(value, 2).toString();\n        }\n        var chars = [\n          value.slice(0, 8),\n          value.slice(8, 16),\n          value.slice(16, 24),\n          value.slice(24, 32)\n        ];\n\n        chars = chars.map(function(v) {\n          return String.fromCharCode(parseInt(v, 2));\n        });\n\n        return chars.join(\"\").replace(/\\0+$/, \"\");\n      }\n\n      /**\r\n     * Converts a NTP timestamp from binary notation to a Date object\r\n     * @param {String} value Bits in binary notation\r\n     * @returns {Date}\r\n     * @private\r\n     */\n    },\n    {\n      key: \"_fromNtpTimestamp\",\n      value: function _fromNtpTimestamp(value) {\n        if (value.length % 2 !== 0) {\n          throw new Error(\n            \"Invalid timestamp format, expected even number of characters\"\n          );\n        }\n\n        var seconds = parseInt(value, 2) / Math.pow(2, value.length / 2),\n          date = new Date(\"Jan 01 1900 GMT\");\n\n        date.setUTCMilliseconds(date.getUTCMilliseconds() + seconds * 1000);\n\n        return date;\n      }\n\n      /**\r\n     * Parses an UDP packet buffer and returns a NTPPacket struct\r\n     * @param {Buffer} udpPacket\r\n     * @returns {NTPPacket}\r\n     */\n    },\n    {\n      key: \"parse\",\n      value: function parse(udpPacket) {\n        var data = [];\n        NtpPacketParser.packetStruct.forEach(function(item) {\n          data[item.name] = undefined;\n        });\n\n        var offset = 0;\n        NtpPacketParser.packetStruct.forEach(function(item) {\n          data[item.name] = NtpPacketParser._getBits(\n            udpPacket,\n            offset,\n            item.bits\n          );\n          if (item.converter) {\n            data[item.name] = item.converter(data[item.name], data);\n          } else {\n            data[item.name] = parseInt(data[item.name], 2);\n          }\n          offset += item.bits;\n        });\n\n        return data;\n      }\n    },\n    {\n      key: \"packetStruct\",\n\n      /**\r\n     * Returns the structure of the UDP packet for parsing\r\n     * @returns {Object}\r\n     */\n      get: function get() {\n        var _this = this;\n\n        return [\n          { name: \"leapIndicator\", bits: 2 },\n          { name: \"version\", bits: 3 },\n          { name: \"mode\", bits: 3 },\n          { name: \"stratum\", bits: 8 },\n          { name: \"poll\", bits: 8 },\n          { name: \"precision\", bits: 8 },\n          {\n            name: \"rootDelay\",\n            bits: 32,\n            converter: NtpPacketParser._fromNtpTimestamp\n          },\n          {\n            name: \"rootDispersion\",\n            bits: 32,\n            converter: NtpPacketParser._fromNtpTimestamp\n          },\n          {\n            name: \"referenceId\",\n            bits: 32,\n            converter: function converter(v, s) {\n              return _this._ntpIdentifier(s.stratum, v);\n            }\n          },\n          {\n            name: \"referenceTimestamp\",\n            bits: 64,\n            converter: NtpPacketParser._fromNtpTimestamp\n          },\n          {\n            name: \"originTimestamp\",\n            bits: 64,\n            converter: NtpPacketParser._fromNtpTimestamp\n          },\n          {\n            name: \"receiveTimestamp\",\n            bits: 64,\n            converter: NtpPacketParser._fromNtpTimestamp\n          },\n          {\n            name: \"transmitTimestamp\",\n            bits: 64,\n            converter: NtpPacketParser._fromNtpTimestamp\n          }\n        ];\n      }\n    }\n  ]);\n\n  return NtpPacketParser;\n})();\n\nexports.default = NtpPacketParser;\n"]},"metadata":{},"sourceType":"script"}